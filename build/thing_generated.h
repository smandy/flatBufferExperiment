// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_THING_ARGO_H_
#define FLATBUFFERS_GENERATED_THING_ARGO_H_

#include "flatbuffers/flatbuffers.h"

namespace argo {

struct Thing;

struct ThingList;

struct Thing FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4
  };
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(VT_NAME); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           verifier.EndTable();
  }
};

struct ThingBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(Thing::VT_NAME, name); }
  ThingBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ThingBuilder &operator=(const ThingBuilder &);
  flatbuffers::Offset<Thing> Finish() {
    auto o = flatbuffers::Offset<Thing>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<Thing> CreateThing(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0) {
  ThingBuilder builder_(_fbb);
  builder_.add_name(name);
  return builder_.Finish();
}

struct ThingList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TITLE = 4,
    VT_THINGS = 6
  };
  const flatbuffers::String *title() const { return GetPointer<const flatbuffers::String *>(VT_TITLE); }
  const flatbuffers::Vector<flatbuffers::Offset<Thing>> *things() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Thing>> *>(VT_THINGS); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TITLE) &&
           verifier.Verify(title()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_THINGS) &&
           verifier.Verify(things()) &&
           verifier.VerifyVectorOfTables(things()) &&
           verifier.EndTable();
  }
};

struct ThingListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_title(flatbuffers::Offset<flatbuffers::String> title) { fbb_.AddOffset(ThingList::VT_TITLE, title); }
  void add_things(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Thing>>> things) { fbb_.AddOffset(ThingList::VT_THINGS, things); }
  ThingListBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ThingListBuilder &operator=(const ThingListBuilder &);
  flatbuffers::Offset<ThingList> Finish() {
    auto o = flatbuffers::Offset<ThingList>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<ThingList> CreateThingList(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> title = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Thing>>> things = 0) {
  ThingListBuilder builder_(_fbb);
  builder_.add_things(things);
  builder_.add_title(title);
  return builder_.Finish();
}

inline const argo::ThingList *GetThingList(const void *buf) { return flatbuffers::GetRoot<argo::ThingList>(buf); }

inline bool VerifyThingListBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<argo::ThingList>(); }

inline void FinishThingListBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<argo::ThingList> root) { fbb.Finish(root); }

}  // namespace argo

#endif  // FLATBUFFERS_GENERATED_THING_ARGO_H_
